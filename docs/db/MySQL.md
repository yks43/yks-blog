
# 多表联查

内连接
* 隐式
* 显示

外连接
* 左外连接
* 右外连接

# 存储引擎
架构图：
![](../images/存储引擎架构图.jpg)
## 连接器
我们要进行查询，第一步就是先去链接数据库，那这个时候就是连接器跟我们对接。

他负责跟客户端建立链接、获取权限、维持和管理连接。

链接的时候会经过TCP握手，然后身份验证，然后我们输入用户名密码就好了。

验证ok后，我们就连上了这个MySQL服务了，但是这个时候我们处于空闲状态。
### 空闲连接
show processlist：Command列显示为Sleep的这一行，就表示现在系统里面有一个空闲连接。
> 数据库的客户端太久没响应，连接器就会自动断开了，这个时间参数是wait_timeout控制住的，默认时长为8小时。断开后重连的时候会报错，如果你想再继续操作，你就需要重连了。

解决方案：
* 重新连接
* 使用长连接

长连接的问题：
* 使用长连接之后，内存会飙得很快，MySQL在执行过程中临时使用的内存是管理在连接对象里面的。只有在连接断开的时候才能得到释放，那如果一直使用长连接，那就会导致OOM（Out Of Memory），会导致MySQL重启，在JVM里面就会导致频繁的Full GC。

解决方案：
* 定期断开长连接，使用一段时间后，或者程序里面判断执行过一个占用内存比较大的查询后就断开连接，需要的时候重连就好了。
* 执行比较大的一个查询后，执行mysql_reset_connection可以重新初始化连接资源。这个过程相比上面一种会好点，不需要重连，但是会初始化连接的状态。

## 查询缓存
MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。

同一条语句在MySQL执行两次，第一次和后面的时间是不一样的，后者明显快一些，这就是因为缓存的存在。

跟Redis一样，只要是你之前执行过的语句，都会在内存里面用key-value形式存储着。

查询的时候就会拿着语句先去缓存中查询，如果能够命中就返回缓存的value，如果不命中就执行后面的阶段。

### 缓存利大于弊
缓存的失效很容易，只要对表有任何的更新，这个表的所有查询缓存就会全部被清空，就会出现缓存还没使用，就直接被清空了，或者积累了很多缓存准备用来着，但是一个更新打回原形。

这就导致查询的命中率低的可怕，只有那种只查询不更新的表适用缓存，但是这样的表往往很少存在，一般都是什么配置表之类的。

### 不用缓存的操作
显示调用，把query_cache_type设置成为DEMAND，这样SQL默认不适用缓存，想用缓存就用SQL_CACHE。

看sql执行时间，但是可能是有缓存的，一般我们就在sql前面使用SQL_NO_CACHE就可以知道真正的查询时间了。
```sql
select SQL_NO_CACHE * from A
```

## 分析器
在缓存没有命中的情况下，就开始执行语句了，检查SQL语句是否有问题，先做词法分析（语句有这么多单词、空格，MySQL就需要识别每个字符串所代表的是什么，是关键字，还是表名，还是列名等等。），然后语法分析（根据词法分析的结果，语法分析会判断你sql的对错，错了会提醒你的，并且会提示你哪里错了。）

## 优化器
分析无误后就进入优化器，优化的东西主要是：确认使用哪一个索引，使用你的主键索引，联合索引还是什么索引更好。；对执行顺序优化，条件那么多，先查哪个表，还是先关联，会出现很多方案，最后由优化器决定选用哪种方案。

## 执行器
优化后就执行了，第一步做权限的判断；执行的时候，就一行一行的去判断是否满足条件，有索引的执行起来可能就好点，一行行的判断就像是接口都提前在引擎定义好了，所以比较快。

# 索引

### 是什么

> 索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据

#### 索引采用的数据结构：
常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树


### 有什么用/解决了什么问题
用处：极大提高数据查询的效率

### 重点

#### 索引分类

聚簇索引
* 在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。

覆盖索引
* 是指一个查询语句的执行只用从索引中就能获得，不必从数据表中读取。当一条查询语句符合覆盖条件时，MySQL只需要通过索引级就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率;

联合索引
* 创建联合索引时，根据业务需求，where字句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则

索引下推
* MYSQL5.6引入了索引下推优化,默认开启,使用 SET optimizer_ switch=
ndex_ condition_ pushdown=off;可以将其关团。官方文档中给的例子和解
释如下:
people表中( zipcode, lastname, firstname)构成一个索引
SELECT* FROM people WHERE zipcode= '95054'AND lastname LIKE
'%etrunia%' AND address LIKE '%Main Street%"
如果没有使用索引下推技不,则 MYSQL会通过 zipcode='95054'从存储引中
查询对应的数据,返回到 MYSQL服务端,然后 MYSQL服务端基于 astname
LIKE '%etruria%'和 address LIKE% 'Main Street%'来判断数据是否符合条
件
如果使用了索引下推技术,则 MYSQLT首先会返回符合 zipcode='95054"的索
引,然后根据 lastname LIKE '%etruria%'和 address LIKE '%Main
Street%'来判断索引是否符合条件。如果符合条件,则根据该索引来定位对应的
数据,如果不符合,则直接 reject掉。有了索引下推优化,可以在有like条件查
询的情况下,减少回表次数


### 面试题
为什么使用B+树？
因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描

B+索引和Hash索引比较起来有什么优缺点吗？
* 哈希索引适合等值查询，无法进行范围查询
* 哈希索引没办法利用索引完成排序
* 哈希索引不支持多列联合索引的最左匹配原则
* 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

B+ Tree的叶子节点都可以存哪些东西吗？
* InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值

聚簇索引与覆盖索引的区别？
* InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引
* 聚簇索引查询会更快；因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询（回表）

排查的时候，有什么手段可以知道有没有走索引查询呢？
* 可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况

什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？
* 一条SQL语句的查询,可以有不同的执行方案,至于最终选择哪种方案,需要通过优化器进行选择,选择执行成本最低的方案。在一条单表查询语句真正执行之前, MYSQL的查询优化器会找出执行该语句所有可能使用的方案,对比之后找出成本最低的方案
这个成本最低的方案就是所谓的执行计划。优化过程大致如下:
1、根据搜条件,找出所有可能使用的索引
2、计算全表扫描的代价
3、计算使用不同索引执行查询的代价
4、对比各种执行方案的代价,找出成本最低的那一个




#### 基础知识
储存结构：页（记录都存在页里面）：
* 各个数据页可以组成一个双向链表
* 而每个数据页中的记录又可以组成一个单向链表
    * 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
    * 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

所以说，如果我们写 `select * from user where username='yks43'`这样没有进行任何优化的sql语句，默认会这样做：
* 定位到记录所在的页
    * 需要遍历双向链表，找到所在的页
* 从所在的页内中查找相应的记录
    * 由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会很慢！

#### 为什么索引会提高检索速度

> 将无序的数据变成有序（相对）

没有用索引我们是需要遍历双向链表来定位对应的页，现在通过“目录”就可以很快地定位到对应的页上了！
其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

#### 索引会降低增删改查的速度

B+树是平衡树的一种

> 平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合矮矮胖胖(均衡)的结构)【这样一来我们检索的时间复杂度就是O(logn)】！建立索引实际上就是建立一颗B+树。

* B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会破坏它的原有结构。

* 要维持平衡树，就必须做额外的工作。正因为这些额外的工作开销，导致索引会降低增删改的速度

#### 哈希索引
除了B+树之外，还有一种常见的是哈希索引。

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

* 本质上就是把键值换算成新的哈希值，根据这个哈希值来定位。
##### 局限
* 哈希索引也没办法利用索引完成排序
* 不支持最左匹配原则
* 在有大量重复键值情况下，哈希索引的效率也是极低的---->哈希碰撞问题。
* 不支持范围查询

### InnoDB支持哈希索引吗？
主流的还是使用B+树索引比较多，对于哈希索引，InnoDB是自适应哈希索引的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！

### 聚集和非聚集索引

概括：
* 聚集索引就是以主键创建的索引
* 非聚集索引（二级索引）就是以非主键创建的索引

区别：
* 聚集索引在叶子节点存储的是表中的数据
* 非聚集索引在叶子节点存储的是主键和索引列
* 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)

非聚集索引在建立的时候也未必是单列的，可以多个列来创建索引。
* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则-->后面有说)
* 创建多个单列(非聚集)索引的时候，会生成多个索引树(所以过多创建索引会占用磁盘空间)

在创建多列索引中也涉及到了一种特殊的索引-->覆盖索引
* 如果不是聚集索引，叶子节点存储的是主键+列值，最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢
* 覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
比如：
* 现在我创建了索引 `(username,age)`，在查询数据的时候： `select user name, age from user where username='yks43'and age=20`
* 很明显地知道，我们上边的查询是走索引的，并且，要查询出的列在叶子节点都存在！所以，就不用回表了~

### 索引最左匹配原则

* 索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。
* 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
* 因此，列的排列顺序决定了可命中索引的列数。

比如：
* 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)
* 举个简单例子： select * from user where age>30; 如果在age列创建索引，那你说会走索引吗？   

### =、in自动优化顺序
不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：
如有索引 (a,b,c,d)，查询条件 c>3 and b=2 and a=1 and d<4与 a=1 and c>3 and b=2 and d<4等顺序都是可以的，MySQL会自动优化为 a=1 and b=2 and c>3 and d<4，依次命中a、b、c。

### 总结
* 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。
* 尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
* 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
* 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，~~MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引 --- 还是应该建立起比较好的索引，而不应该依赖于“合并索引”这么一个策略)。
* “合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来
# 锁

### 为什么要学习锁
即使我们不会这些锁知识，我们的程序在一般情况下还是可以跑得好好的。因为这些锁数据库隐式帮我们加了
* 对于 UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)
* MyISAM在执行查询语句 SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（ UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预

只会在某些特定的场景下才需要手动加锁，学习数据库锁知识就是为了:
* 能让我们在特定的场景下派得上用场
* 更好把控自己写的程序
* 构建自己的知识库体系！在面试的时候不虚

### 介绍

送锁的粒度分:
* 表锁：
    * 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
* 行锁
    * 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

存储引擎
* InnoDB行锁表锁都支持
* MyISAM只支持表锁

InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁
* InnoDB的行锁是基于索引的！

表锁分为两种模式
* 表读锁
* 表写锁
* 在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！
    * 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
    * 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁
    * 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁

# MySQL主从复制
> 将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致

## 原理
* MySql主库在事务提交时会把数据变更作为事件记录在二进制日志Binlog中；
* 主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；
* MySql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑着从库上；
* 当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用

## Docker搭建测试
### 主实例搭建
运行MySQL主实例：
```shell
docker run -p 3307:3306 --name mysql-master \
-v /mydata/mysql-master/log:/var/log/mysql \
-v /mydata/mysql-master/data:/var/lib/mysql \
-v /mydata/mysql-master/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root  \
-d mysql:5.7
```

在mysql的配置文件夹/mydata/mysql-master/conf中创建一个配置文件my.cnf：
```shell
touch my.cnf
```
修改配置文件my.cnf，配置信息如下：
```cnf
[mysqld]
## 设置server_id，同一局域网中需要唯一
server_id=101
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql
## 开启二进制日志功能
log-bin=mall-mysql-bin
## 设置二进制日志使用内存大小（事务）
binlog_cache_size=1M
## 设置使用的二进制日志格式（mixed,statement,row）
binlog_format=mixed
## 二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
```
修改完配置后重启实例，并进入到master容器中，连接到客户端：
```shell
docker restart mysql-master
docker exec -it mysql-master /bin/bash
mysql -uroot -proot
```
创建数据同步用户
```shell
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';
```

### 从实例搭建
运行MySQL从实例
```shell
docker run -p 3308:3306 --name mysql-slave \
-v /mydata/mysql-slave/log:/var/log/mysql \
-v /mydata/mysql-slave/data:/var/lib/mysql \
-v /mydata/mysql-slave/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root  \
-d mysql:5.7
```
在mysql的配置文件夹/mydata/mysql-slave/conf中创建一个配置文件my.cnf，并修改：
```shell
touch my.cnf
```
```cnf
mysqld]
## 设置server_id，同一局域网中需要唯一
server_id=102
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql
## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用
log-bin=mall-mysql-slave1-bin
## 设置二进制日志使用内存大小（事务）
binlog_cache_size=1M
## 设置使用的二进制日志格式（mixed,statement,row）
binlog_format=mixed
## 二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
## relay_log配置中继日志
relay_log=mall-mysql-relay-bin
## log_slave_updates表示slave将复制事件写进自己的二进制日志
log_slave_updates=1
## slave设置为只读（具有super权限的用户除外）
read_only=1
```
修改完配置后重启实例：
```shell
docker restart mysql-slave
```

### 主从数据库进行连接
连接到主数据库的mysql客户端，查看主数据库状态：
```shell
mysql> show master status;
```
进入mysql-slave容器中，连接到客户端，在数据库中配置主从复制
```shell
change master to master_host='192.168.6.132', master_user='slave', master_password='123456', master_port=3307, master_log_file='mall-mysql-bin.000001', master_log_pos=617, master_connect_retry=30;
```
查看主从同步状态
```
show slave status \G;
```
开启主从同步
```
start slave;
```
参数说明
```
master_host：主数据库的IP地址；
master_port：主数据库的运行端口；
master_user：在主数据库创建的用于同步数据的用户账号；
master_password：在主数据库创建的用于同步数据的用户密码；
master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；
master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；
master_connect_retry：连接失败重试的时间间隔，单位为秒。
```

### 测试
* 在主实例中创建一个数据库yks
* 在从实例中查看数据库，发现也有一个yks数据库，可以判断主从复制已经搭建成功。



# MySQL调优
* 加索引
* 先用explain跑一遍SQL
* 排除缓存干扰（SQL NoCache）
MySQL8.0之前数据库是存在缓存的，有可能缓存失效，导致Response time 时高时低，缓存失效的原因：
当前MySQL版本存在缓存时，每次请求的查询语句都会以key=value的形式存入到缓存中，当我们对一张表进行更新，这个表所有的缓存都会被清空，这个时候缓存就走不到了
8.0之后的版本，缓存就被取消了
* explain
* 