
## 多表联查

内连接
* 隐式
* 显示

外连接
* 左外连接
* 右外连接



## 索引

#### 基础知识
储存结构：页（记录都存在页里面）：
* 各个数据页可以组成一个双向链表
* 而每个数据页中的记录又可以组成一个单向链表
    * 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
    * 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

所以说，如果我们写 `select * from user where username='yks43'`这样没有进行任何优化的sql语句，默认会这样做：
* 定位到记录所在的页
    * 需要遍历双向链表，找到所在的页
* 从所在的页内中查找相应的记录
    * 由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会很慢！

#### 为什么索引会提高检索速度

> 将无序的数据变成有序（相对）

没有用索引我们是需要遍历双向链表来定位对应的页，现在通过“目录”就可以很快地定位到对应的页上了！
其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

#### 索引会降低增删改查的速度

B+树是平衡树的一种

> 平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合矮矮胖胖(均衡)的结构)【这样一来我们检索的时间复杂度就是O(logn)】！建立索引实际上就是建立一颗B+树。

* B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会破坏它的原有结构。

* 要维持平衡树，就必须做额外的工作。正因为这些额外的工作开销，导致索引会降低增删改的速度

#### 哈希索引
除了B+树之外，还有一种常见的是哈希索引。

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

* 本质上就是把键值换算成新的哈希值，根据这个哈希值来定位。
##### 局限
* 哈希索引也没办法利用索引完成排序
* 不支持最左匹配原则
* 在有大量重复键值情况下，哈希索引的效率也是极低的---->哈希碰撞问题。
* 不支持范围查询

### InnoDB支持哈希索引吗？
主流的还是使用B+树索引比较多，对于哈希索引，InnoDB是自适应哈希索引的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！

### 聚集和非聚集索引

概括：
* 聚集索引就是以主键创建的索引
* 非聚集索引（二级索引）就是以非主键创建的索引

区别：
* 聚集索引在叶子节点存储的是表中的数据
* 非聚集索引在叶子节点存储的是主键和索引列
* 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)

非聚集索引在建立的时候也未必是单列的，可以多个列来创建索引。
* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则-->后面有说)
* 创建多个单列(非聚集)索引的时候，会生成多个索引树(所以过多创建索引会占用磁盘空间)

在创建多列索引中也涉及到了一种特殊的索引-->覆盖索引
* 如果不是聚集索引，叶子节点存储的是主键+列值，最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢
* 覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
比如：
* 现在我创建了索引 `(username,age)`，在查询数据的时候： `select user name, age from user where username='yks43'and age=20`
* 很明显地知道，我们上边的查询是走索引的，并且，要查询出的列在叶子节点都存在！所以，就不用回表了~

### 索引最左匹配原则

* 索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。
* 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
* 因此，列的排列顺序决定了可命中索引的列数。

比如：
* 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)
* 举个简单例子： select * from user where age>30; 如果在age列创建索引，那你说会走索引吗？   

### =、in自动优化顺序
不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：
如有索引 (a,b,c,d)，查询条件 c>3 and b=2 and a=1 and d<4与 a=1 and c>3 and b=2 and d<4等顺序都是可以的，MySQL会自动优化为 a=1 and b=2 and c>3 and d<4，依次命中a、b、c。

### 总结
* 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。
* 尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
* 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
* 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，~~MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引 --- 还是应该建立起比较好的索引，而不应该依赖于“合并索引”这么一个策略)。
* “合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来
## 锁

### 为什么要学习锁
即使我们不会这些锁知识，我们的程序在一般情况下还是可以跑得好好的。因为这些锁数据库隐式帮我们加了
* 对于 UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)
* MyISAM在执行查询语句 SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（ UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预

只会在某些特定的场景下才需要手动加锁，学习数据库锁知识就是为了:
* 能让我们在特定的场景下派得上用场
* 更好把控自己写的程序
* 构建自己的知识库体系！在面试的时候不虚

### 介绍

送锁的粒度分:
* 表锁：
    * 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
* 行锁
    * 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

存储引擎
* InnoDB行锁表锁都支持
* MyISAM只支持表锁

InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁
* InnoDB的行锁是基于索引的！

表锁分为两种模式
* 表读锁
* 表写锁
* 在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！
    * 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
    * 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁
    * 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁

