### 冒泡排序
##### 思路：

* 两两交换，大的放在后面，第一次排序后最大数已经在数组末尾
* 需要n-1趟排序
  

##### 实现要点：

* 两个for循环，外层循环控制排序的趟数，内层循环控制比较的次数
* 每趟过后，比较的次数都应该要减1
* **优化：**如果一趟排序后也没有交换位置，那么该数组已有序～

```java
  //外层循环是排序的趟数
    for (int i = 0; i < arrays.length -1 ; i++) {
        //每比较一趟就重新初始化为0
        isChange = 0;
        //内层循环是当前趟数需要比较的次数
        for (int j = 0; j < arrays.length - i - 1; j++) {
            //前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
            if (arrays[j] > arrays[j + 1]) {
                temp = arrays[j];
                arrays[j] = arrays[j + 1];
                arrays[j + 1] = temp;

                //如果进到这里面了，说明发生置换了
                isChange = 1;
            }
        }
        //如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了
        if (isChange == 0) {
            break;
        }
    }
    System.out.println(arrays);
```



### 选择排序

##### 思路：

*   找到数组中最大的元素，与数组最后一位元素交换
*   当只有一个数时，则不需要选择了，因此需要`n-1`趟排序，比如10个数，需要9趟排序

##### 实现要点：

```java
for (int i = 0; i < arrays.length-1; i++) {
 	//新的趟数、将角标重新赋值为0
    pos = 0;
    //内层循环控制遍历数组的个数，并得到最大数的角标
    for (int j = 0; j < arrays.length - i; j++) {
        if (arrays[j] > arrays[pos]) {
            pos = j;
        }
    }
    //交换
    temp = arrays[pos];
    arrays[pos] = arrays[arrays.length - 1 - i];
    arrays[arrays.length - 1 - i] = temp;
}

System.out.println(arrays);
```



### 插入排序

##### 要点：

*   将一个元素插入到已有序的数组里，默认将第一个元素看成有序的
*   插入时与有序数组比较，比它大则直接插入，比它小则移动数组元素的位置，找到一个合适的位置插入
*   当只有一个数时，则不需要插入了，因此需要n-1趟排序

##### 实现要点：

*   一个for循环内嵌套另一个while循环，外层for循环控制趟数，while循环找到合适的位置插入

```java
//临时变量
int temp = 0;
for (int i = 0; i < arrays.length-1; i++) {
	temp = arrays[i];
    while (i>= 1 && array[i-1] > temp) {

    }
}
```

