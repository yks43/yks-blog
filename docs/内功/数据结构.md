# 数据结构
> 数据结构包括数据对象集以及它们在计算机中的组织方式，即它们的逻辑结构和物理存储结构，一般我们可以认为数据结构指的是一组数据的存储结构。

逻辑结构：可以用什么的表示方式来描述

物理结构：元素实际的存储形式
## 线性表结构
> 就是将数据排成像一条长线一样的结构
### 数组
> 数组是一种**线性表数据结构**，它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。

#### 特点：
* 高效的随机访问

寻址公式计算要访问的元素在内存中的地址：
计算机通过数组的首地址和寻址公式能够很快速的找到想要访问的元素
```java
//dataTypeSize 代表数组中元素类型的大小
a[i] = baseAddress + i * dataTypeSize
```

* 低效插入和删除

为保证内存数据的连续性，需要做大量的数据搬移

#### 应用
* ArrayList

可以将很多数组操作的细节封装起来。比如数组插入、删除数据时需要搬移其他数据等，支持动态扩容（1.5倍）：
扩容操作涉及内存申请和数据搬移，是比较耗时的。所以， 如果事先能确定需要存储的数据大小，最好在创建ArrayList 的时候事先指定数据大小。


### 链表
#### 概念
> 链表（Linked list）是一种物理存储单元上非连续、非顺序的存储结构，数据元素
的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一
个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一
个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域

#### 存储结构
* 数组

需要一块连续的存储空间，对内存的要求比较高，比如我们要申请一个1000M 的数组，如果内存中没有连续的足够大的存储空间则会申请失败，即便内存的剩余可用空间大于 1000M，仍然会申请失败
* 链表

与数组相反，它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用，所以如果我们申请一个 1000M 大小的链表，只要内存剩余的可用空间大于 1000M，便不会出现问题。
#### 链表类型
1. 单链表
> 1个指针域，1个数据域
2. 循环链表
> 单链表的尾结点next指针指向链表头结点
3. 双向链表
> 2个指针域，1个数据域
4. 双向循环链表
> 双向链表的头结点pre指针指向尾结点，尾结点的next指针指向头结点
#### 数组和链表的性能比较
* 数组
查询快增删慢
* 链表
增删快查询慢
#### 链表的应用
* LinkedList

### 栈

### 队列
## 非线性结构
### 树
#### 二叉树
### 堆
### 图

## 面试题
1. LinkedList 和 ArrayList 的比较
2. 反转单链表
```java

/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode(int x) { val = x; }
* }
*/
//迭代
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null; //前指针节点
        ListNode curr = head; //当前指针节点
        //每次循环，都将当前节点指向它前面的节点，然后当前节点和前节点后移
        while (curr != null) {
            ListNode nextTemp = curr.next; //临时节点，暂存当前节点的下一   节点，用于后移
            curr.next = prev; //将当前节点指向它前面的节点
            prev = curr; //前指针后移
            curr = nextTemp; //当前指针后移
        }
        return prev;
    }
}
//递归
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode node = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return node;
    }
}

```
