## 三大特性
### 封装

>   封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了

### 继承

>   不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

注意：

*   子类的修饰符应>=父类
*   子类的异常<=父类

### 多态

>   多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。

注意：

*   对象类型和引用类型之间具有继承（类）/实现（接口）的关系；

多态的必要条件：
1. 要有继承
2. 要有重写
3. 父类引用指向子类对象

## 数据类型

1. 6种数字类型 ：byte、short、int、long、float、double
2. 1种字符类型：char
3. 1种布尔型：boolean。

这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean

| 基本类型 | 位数 | 字节 | 默认值  |
| -------- | ---- | ---- | ------- |
| int      | 32   | 4    | 0       |
| short    | 16   | 2    | 0       |
| long     | 64   | 8    | 0L      |
| byte     | 8    | 1    | 0       |
| char     | 16   | 2    | 'u0000' |
| float    | 32   | 4    | 0f      |
| double   | 64   | 8    | 0d      |
| boolean  | 1    |      | false   |




# 常见的面试问题

### 既然有了字节流,为什么还要有字符流?

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

### i++和++i
	 i++ 先赋值在运算,例如 a=i++,先赋值a=i,后运算i=i+1,所以结果是a==1
	 ++i 先运算在赋值,例如 a=++i,先运算i=i+1,后赋值a=i,所以结果是a==2
### 移位运算>>和<<
     >> 右移，除以2
     << 左移，乘以2

### ==与equals()
* 基本数据类型：比较的是值
* 引用数据类型：
  * 没有重写equals：比较的是堆内存地址；
  * 重写equals时，按照重写的规则来比较，重写满足自反性 ，对称性，传递性，一致性，和非null。
### equals与hashcode

hashCode()这个方法主要是为了更好支持哈希表（HashMap、HashSet、HashTable等）

哈希表的存储原理：
当我们向哈希表插入一个object时，首先调用hashCode()方法获得该对象的哈希码，通过该哈希码直接定位object在哈希表中的 位置。如果该位置没有对象，将object插入该位置，如果该位置有对象（可能有多个，通过链表实现），则调用equals（）方法将这些对象与object比较，如果相等，则不需要保存object，否则，将该对象插入到该链表中。

所以 equals()相等，则hashCode()必须相等。

重写equals() 方法之后，必须重写HashCode（）方法。

重写HashCode注意：
如果重写equals()，两个对象equals()方法判断相等，则对应的HashCode也是相等的 如果不等 ，则需要重写HashCode方法。
hashCode 不能简单到容易造成Hash冲突
HashCode不能太复杂，以至于影响性能。


